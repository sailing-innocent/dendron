"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsertNoteIndexCommand = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const vscode_1 = require("vscode");
const clientUtils_1 = require("../clientUtils");
const constants_1 = require("../constants");
const vsCodeUtils_1 = require("../vsCodeUtils");
const WSUtils_1 = require("../WSUtils");
const base_1 = require("./base");
class InsertNoteIndexCommand extends base_1.BasicCommand {
    constructor(_ext) {
        super();
        this._ext = _ext;
        this.key = constants_1.DENDRON_COMMANDS.INSERT_NOTE_INDEX.key;
    }
    // TODO: make this into a util once the cli version is implemented.
    // NOTE: the marker flag is not exposed to the plugin yet.
    genNoteIndex(notes, opts) {
        const listItems = notes.map((note) => {
            const link = common_all_1.NoteUtils.createWikiLink({
                note,
                useVaultPrefix: clientUtils_1.DendronClientUtilsV2.shouldUseVaultPrefix(this._ext.getEngine()),
                alias: { mode: "title" },
            });
            return `- ${link}`;
        });
        let payload = ["## Index", listItems.join("\n")];
        if (opts.marker) {
            payload = [
                "<!-- Autogenerated Index Start -->",
                ...payload,
                "<!-- Autogenerated Index End -->",
            ];
        }
        return payload.join("\n");
    }
    async execute(opts) {
        const ctx = "InsertNoteIndexCommand";
        this.L.info({ ctx, msg: "execute", opts });
        const maybeEditor = vsCodeUtils_1.VSCodeUtils.getActiveTextEditor();
        if (lodash_1.default.isUndefined(maybeEditor)) {
            vscode_1.window.showErrorMessage("No active text editor found. Try running this command in a Dendron note.");
            return opts;
        }
        const activeNote = await WSUtils_1.WSUtils.getNoteFromDocument(maybeEditor.document);
        if (lodash_1.default.isUndefined(activeNote)) {
            vscode_1.window.showErrorMessage("Active file is not a Dendron note.");
            return opts;
        }
        const engine = this._ext.getEngine();
        const bulkResp = await engine.bulkGetNotesMeta(activeNote.children);
        const children = bulkResp.data;
        if (children.length === 0) {
            vscode_1.window.showInformationMessage("This note does not have any child notes.");
            return opts;
        }
        const { config } = this._ext.getDWorkspace();
        const insertNoteIndexConfig = common_all_1.ConfigUtils.getCommands(config).insertNoteIndex;
        const maybeMarker = insertNoteIndexConfig.enableMarker;
        const noteIndex = this.genNoteIndex(children, {
            marker: opts.marker ? opts.marker : maybeMarker,
        });
        const current = maybeEditor.selection;
        await maybeEditor.edit((builder) => {
            builder.insert(current.start, noteIndex);
        });
        return opts;
    }
}
exports.InsertNoteIndexCommand = InsertNoteIndexCommand;
//# sourceMappingURL=InsertNoteIndexCommand.js.map